Define Tuple be (Let X; Let Y; List (X Y));

Define For as
( Let Lst; Let Body;
  Do If (Empty? Lst) then ()
  else (
    push First element in Lst;
    Do evaluate Body;
    For each in Rest of Lst
      Body;
  );
);

Define Range as
( Let A; Let B; Let S;
  List from
  (
    Define Count as
    (
      Let X;
      Do If (X; < B)
      (
        return X;
        Count from + X S;
      ) else ();
    );
    Count from A;
  );
);

Define Splice as
( Let List1; Let List2;
  Do If (Either Empty? List1 or Empty? List2) then (return List())
  else (
    Let T be a Tuple from First in List1 and First in List2;
    Push T to Splice of Rest of List1 and Rest of List2;
  );
);

Define Integer?
( Let X;
  X; == Floor X;
);


Define Filter
( Let Cond; Let Lst;
  Do If (Empty? Lst) then (return Lst)
  else (
    Let Result be Do Cond on First of Lst;
    Filter with Cond over the Rest of Lst;
    Do If (Result) (Push First Lst) else ();
  );
);

Define Map
( Let Expr; Let Lst;
  Do If (Empty? Lst) then (return Lst)
  else (
    Let Result be Do Expr on First in Lst;
    Map Expr over the Rest of the Lst;
    Push Result to that list;
  );
);

Define Prepend
( Let L1 be the first list;
  Let L2 be the second list;
  Do If (L1; is Empty?) then (return L2)
  else
  (
    Prepend the Rest of L1 to L2;
    Push the First element in L1 to the resulting list;
  )
);

Define Append (Swap; Prepend);

Define Concat
( Let N be the number of lists to concatenate;
  List();
  For each in Range from 0 to N step 1 (Drop the index; Prepend);
)

Define Length
( Let L be a list;
  Do If (L; is Empty?) (return 0) else (return Length of Rest of L; + 1);
)
