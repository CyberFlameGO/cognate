!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BLOCK	cognate.h	119;"	d
BLOCK_GC	runtime.c	19;"	d	file:
CALL	cognate.h	94;"	d
CHECK	cognate.h	93;"	d
DEFINE	cognate.h	96;"	d
DOIF	cognate.h	137;"	d
GC_MALLOC	cognate.h	127;"	d
GC_NEW	cognate.h	131;"	d
GC_REALLOC	cognate.h	128;"	d
GC_STRDUP	cognate.h	130;"	d
GC_STRNDUP	cognate.h	129;"	d
INITIAL_LIST_SIZE	cognate.h	10;"	d
INITIAL_READ_SIZE	cognate.h	9;"	d
INITIAL_TABLE_SIZE	cognate.h	11;"	d
LET	cognate.h	107;"	d
LIST_GROWTH_FACTOR	cognate.h	12;"	d
MAX_TABLE_TRIES	cognate.h	8;"	d
NOTHING	cognate.h	/^  NOTHING = 0, \/\/ Must be zero because of calloc()$/;"	e	enum:cognate_type
OBJ	cognate.h	91;"	d
PROGRAM	cognate.h	111;"	d
REDEFINE	cognate.h	105;"	d
SET	cognate.h	109;"	d
STACK_MARGIN_KB	cognate.h	13;"	d
VAR	cognate.h	92;"	d
_GNU_SOURCE	cognate.h	3;"	d
___assert	functions.c	/^void ___assert(cognate_string name, cognate_boolean result) {$/;"	f
___block_	functions.c	/^cognate_boolean ___block_(cognate_object a)   { return a.type&block;  }$/;"	f
___boolean_	functions.c	/^cognate_boolean ___boolean_(cognate_object a) { return a.type&boolean;}$/;"	f
___both	functions.c	/^cognate_boolean ___both  (cognate_boolean a, cognate_boolean b) { return a && b; }$/;"	f
___ceiling	functions.c	/^cognate_number ___ceiling(cognate_number a) {$/;"	f
___character	functions.c	/^cognate_string ___character(cognate_number d) {$/;"	f
___characters	functions.c	/^void ___characters() {$/;"	f
___clear	functions.c	/^void ___clear()                                  { stack.top=stack.start; }$/;"	f
___divide	functions.c	/^cognate_number ___divide(cognate_number a, cognate_number b)   { if likely(a) return b \/ a; throw_error("Division of %.14g by zero", b); }$/;"	f
___do	functions.c	/^void ___do(cognate_block blk) { blk(); }$/;"	f
___drop	functions.c	/^void ___drop(cognate_object a)                   { (void)a; } \/\/ These can be defined within cognate.$/;"	f
___either	functions.c	/^cognate_boolean ___either(cognate_boolean a, cognate_boolean b) { return a || b; }$/;"	f
___empty_	functions.c	/^cognate_boolean ___empty_(cognate_list lst) {$/;"	f
___equal	functions.c	/^cognate_boolean ___equal(cognate_object a, cognate_object b)   { return compare_objects(a,b); }$/;"	f
___equalorexceed	functions.c	/^cognate_boolean ___equalorexceed(cognate_number a, cognate_number b)  { return a <= b; }$/;"	f
___equalorpreceed	functions.c	/^cognate_boolean ___equalorpreceed(cognate_number a, cognate_number b) { return a >= b; }$/;"	f
___error	functions.c	/^void ___error(cognate_string str) {$/;"	f
___exceed	functions.c	/^cognate_boolean ___exceed(cognate_number a, cognate_number b)  { return a < b; }$/;"	f
___false	functions.c	/^cognate_boolean ___false() { return 0; }$/;"	f
___first	functions.c	/^void ___first(cognate_list lst) {$/;"	f
___floor	functions.c	/^cognate_number ___floor(cognate_number a) {$/;"	f
___get	functions.c	/^void ___get(cognate_string key, cognate_table tab) {$/;"	f
___head	functions.c	/^cognate_string ___head(cognate_string str)$/;"	f
___if	functions.c	/^void ___if(cognate_block cond, cognate_object a, cognate_object b)$/;"	f
___input	functions.c	/^cognate_string ___input() {$/;"	f
___insert	functions.c	/^cognate_table ___insert(cognate_string key, cognate_object value, cognate_table tab) {$/;"	f
___join	functions.c	/^void ___join(cognate_number n) {$/;"	f
___list	functions.c	/^cognate_list ___list(cognate_block expr) {$/;"	f
___list_	functions.c	/^cognate_boolean ___list_(cognate_object a)    { return a.type&number; } \/\/ However all other symbols are too.$/;"	f
___match	functions.c	/^cognate_boolean ___match(cognate_string reg_str, cognate_string str) {$/;"	f
___modulo	functions.c	/^cognate_number ___modulo(cognate_number a, cognate_number b) {$/;"	f
___multiply	functions.c	/^cognate_number ___multiply(cognate_number a, cognate_number b) { return a * b; }$/;"	f
___not	functions.c	/^cognate_boolean ___not   (cognate_boolean a)                    { return !a;     }$/;"	f
___number	functions.c	/^cognate_number ___number(cognate_string str) {$/;"	f
___number_	functions.c	/^cognate_boolean ___number_(cognate_object a)  { return a.type&number; } \/\/ Question marks are converted to underscores.$/;"	f
___one_of	functions.c	/^cognate_boolean ___one_of(cognate_boolean a, cognate_boolean b) { return a ^ b;  }$/;"	f
___ordinal	functions.c	/^cognate_number ___ordinal(cognate_string str) {$/;"	f
___parameters	functions.c	/^cognate_list ___parameters() {$/;"	f
___path	functions.c	/^cognate_string ___path() {$/;"	f
___preceed	functions.c	/^cognate_boolean ___preceed(cognate_number a, cognate_number b) { return a > b; }$/;"	f
___print	functions.c	/^void ___print(cognate_object a) { print_object(a, stdout, 0); putc('\\n', stdout); }$/;"	f
___push	functions.c	/^cognate_list ___push(cognate_object a, cognate_list b) {$/;"	f
___put	functions.c	/^void ___put(cognate_object a)   { print_object(a, stdout, 0); fflush(stdout); }$/;"	f
___random	functions.c	/^cognate_number ___random(cognate_number low, cognate_number high, cognate_number step) {$/;"	f
___read	functions.c	/^cognate_string ___read(cognate_string filename) {$/;"	f
___rest	functions.c	/^cognate_list ___rest(cognate_list lst) {$/;"	f
___round	functions.c	/^cognate_number ___round(cognate_number a) {$/;"	f
___split	functions.c	/^void ___split() {$/;"	f
___stack	functions.c	/^void ___stack() {$/;"	f
___stop	functions.c	/^void ___stop() {$/;"	f
___string_	functions.c	/^cognate_boolean ___string_(cognate_object a)  { return a.type&string; } \/\/ So this is a temporary hack!$/;"	f
___string_length	functions.c	/^cognate_number ___string_length(cognate_string str) {$/;"	f
___substring	functions.c	/^cognate_string ___substring(cognate_number startf, cognate_number endf, cognate_string str) {$/;"	f
___subtract	functions.c	/^cognate_number ___subtract(cognate_number a, cognate_number b) { return b - a; }$/;"	f
___sum	functions.c	/^cognate_number ___sum(cognate_number a, cognate_number b)      { return a + b; }$/;"	f
___swap	functions.c	/^void ___swap(cognate_object a, cognate_object b) { push(a); push(b); }$/;"	f
___table	functions.c	/^cognate_table ___table() {$/;"	f
___tail	functions.c	/^cognate_string ___tail(cognate_string str)$/;"	f
___triplet	functions.c	/^void ___triplet(cognate_object a)                { push(a); push(a); push(a); }$/;"	f
___true	functions.c	/^cognate_boolean ___true()  { return 1; }$/;"	f
___twin	functions.c	/^void ___twin(cognate_object a)                   { push(a); push(a); }$/;"	f
___unequal	functions.c	/^cognate_boolean ___unequal(cognate_object a, cognate_object b) { return !compare_objects(a,b); }$/;"	f
___values	functions.c	/^cognate_list ___values(cognate_table tab) {$/;"	f
___while	functions.c	/^void ___while(cognate_block cond, cognate_block body) {$/;"	f
___write	functions.c	/^void ___write(cognate_string filename, cognate_object obj) {$/;"	f
blk_alloc	runtime.c	/^void* blk_alloc(const unsigned long size, __attribute__((unused)) const _Bool _, __attribute__((unused)) const _Bool __) { return GC_MALLOC(size); }$/;"	f
blk_gc_assign_strong	runtime.c	/^void blk_gc_assign_strong(void* src, void** dst) { *dst = src; }$/;"	f
blk_gc_assign_weak	runtime.c	/^void blk_gc_assign_weak(const void* src, void* dst) { *(void**)dst = (void*)src; }$/;"	f
blk_gc_memmove	runtime.c	/^void blk_gc_memmove(void* dst, void* src, unsigned long size) { memmove(dst, src, size); }$/;"	f
blk_setHasRefcount	runtime.c	/^void blk_setHasRefcount(__attribute__((unused)) const void* _, __attribute__((unused)) const _Bool __) {}$/;"	f
block	cognate.h	/^    cognate_block   block;     \/\/ 64bit block pointer$/;"	m	union:cognate_object::__anon1
block	cognate.h	/^  block = (1 << 5),$/;"	e	enum:cognate_type
boolean	cognate.h	/^    cognate_boolean boolean;   \/\/ 1bit bool$/;"	m	union:cognate_object::__anon1
boolean	cognate.h	/^  boolean = (1 << 0),$/;"	e	enum:cognate_type
check_function_stack_size	runtime.c	/^void check_function_stack_size()$/;"	f
check_type	runtime.c	/^cognate_object check_type(cognate_type expected_type, cognate_object object)$/;"	f
cleanup	runtime.c	/^void cleanup()$/;"	f
cmdline_parameters	runtime.c	/^cognate_list cmdline_parameters   = NULL;$/;"	v
cognate_boolean	cognate.h	/^typedef _Bool cognate_boolean;$/;"	t
cognate_list	cognate.h	/^typedef const struct cognate_list_node* cognate_list;$/;"	t	typeref:struct:cognate_list_node
cognate_list_node	cognate.h	/^struct cognate_list_node$/;"	s
cognate_list_node	cognate.h	/^typedef struct cognate_list_node cognate_list_node;$/;"	t	typeref:struct:cognate_list_node
cognate_number	cognate.h	/^typedef double cognate_number;$/;"	t
cognate_object	cognate.h	/^struct cognate_object$/;"	s
cognate_object	cognate.h	/^typedef struct cognate_object cognate_object;$/;"	t	typeref:struct:cognate_object
cognate_stack	cognate.h	/^struct cognate_stack$/;"	s
cognate_stack	cognate.h	/^typedef struct cognate_stack  cognate_stack;$/;"	t	typeref:struct:cognate_stack
cognate_string	cognate.h	/^typedef const char* cognate_string;$/;"	t
cognate_table	cognate.h	/^typedef _Bool cognate_table;$/;"	t
cognate_type	cognate.h	/^enum cognate_type$/;"	g
cognate_type	cognate.h	/^typedef enum cognate_type cognate_type;$/;"	t	typeref:enum:cognate_type
compare_lists	runtime.c	/^_Bool compare_lists(cognate_list lst1, cognate_list lst2)$/;"	f
compare_objects	runtime.c	/^_Bool compare_objects(cognate_object ob1, cognate_object ob2)$/;"	f
compare_tables	runtime.c	/^_Bool compare_tables(const cognate_table tab1, const cognate_table tab2)$/;"	f
copy_if_block	runtime.c	/^cognate_object copy_if_block(cognate_object obj)$/;"	f
copy_stack_blocks	runtime.c	/^void copy_stack_blocks()$/;"	f
current_function_name	runtime.c	/^const char *current_function_name = NULL;$/;"	v
current_word_name	runtime.c	/^const char *current_word_name     = NULL;$/;"	v
expand_stack	runtime.c	/^void expand_stack()$/;"	f
function_stack_start	runtime.c	/^static const char *function_stack_start;$/;"	v	file:
function_stack_top	runtime.c	/^static const char *function_stack_top;$/;"	v	file:
handle_error_signal	runtime.c	/^void handle_error_signal(int sig)$/;"	f
heap_block	cognate.h	/^    cognate_block   heap_block;\/\/ 64bit block pointer$/;"	m	union:cognate_object::__anon1
heap_block	cognate.h	/^  heap_block = (1 << 5) | (1 << 6)$/;"	e	enum:cognate_type
immutable	cognate.h	88;"	d
init	runtime.c	/^void init(int argc, char** argv)$/;"	f
init_stack	runtime.c	/^void init_stack()$/;"	f
likely	cognate.h	135;"	d
list	cognate.h	/^    cognate_list    list;      \/\/ 64bit list pointer$/;"	m	union:cognate_object::__anon1
list	cognate.h	/^  list = (1 << 3),$/;"	e	enum:cognate_type
lookup_type	runtime.c	/^const char* lookup_type(cognate_type type)$/;"	f
mbstrlen	functions.c	/^static size_t mbstrlen(const char* str)$/;"	f	file:
mutable	cognate.h	89;"	d
next	cognate.h	/^  cognate_list next;$/;"	m	struct:cognate_list_node
number	cognate.h	/^    cognate_number  number;    \/\/ 64bit float$/;"	m	union:cognate_object::__anon1
number	cognate.h	/^  number = (1 << 2),$/;"	e	enum:cognate_type
object	cognate.h	/^  cognate_object object;$/;"	m	struct:cognate_list_node
peek	runtime.c	/^cognate_object peek()$/;"	f
pop	runtime.c	/^cognate_object pop()$/;"	f
print_object	runtime.c	/^void print_object (const cognate_object object, FILE* out, const _Bool quotes)$/;"	f
push	runtime.c	/^void push(cognate_object object)$/;"	f
r0	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r0	tests/.branch.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(true,())));),OBJ(string,"PASS: If True"),OBJ(string,"FAIL: If True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(false,())));),OBJ(string,"FAIL: If False"),OBJ(string,"PASS: If False")));const cognate_object r1 = pop();CALL(print,(r1));)$/;"	v
r0	tests/.io.c	/^PROGRAM(push(OBJ(string,CALL(read,("tests\/io.txt"))));CALL(if,(BLOCK(const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"foo\\nbar"),r0))));),OBJ(string,"PASS: Reading multi-line file to string"),OBJ(string,"FAIL: Reading multi-line file to string")));const cognate_object r0 = pop();CALL(print,(r0));)$/;"	v
r0	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r0	tests/.stack.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(number,2));CALL(drop,(OBJ(number,3)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,2),r0))));),OBJ(string,"PASS: Drop"),OBJ(string,"FAIL: Drop")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(CALL(swap,(OBJ(number,6),OBJ(number,5)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,5),r0))));),OBJ(string,"PASS: Swap"),OBJ(string,"FAIL: Swap")));const cognate_object r1 = pop();CALL(print,(r1));const cognate_object r2 = pop();CALL(drop,(r2));CALL(if,(BLOCK(CALL(twin,(OBJ(number,4)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,4),r1))));),OBJ(string,"PASS: Twin"),OBJ(string,"FAIL: Twin")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(CALL(triplet,(OBJ(number,7)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();CALL(drop,(r1));const cognate_object r2 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,7),r2))));),OBJ(string,"PASS: Triplet"),OBJ(string,"FAIL: Triplet")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(number,1));push(OBJ(number,2));push(OBJ(number,3));CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK(push(OBJ(number,1)); push(OBJ(number,2)); push(OBJ(number,3));)))),r0))));),OBJ(string,"PASS: Stack as list"),OBJ(string,"FAIL: Stack as list")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(CALL(clear,());CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK()))),r0))));),OBJ(string,"PASS: Clearing the stack"),OBJ(string,"FAIL: Clearing the stack")));const cognate_object r6 = pop();CALL(print,(r6));)$/;"	v
r0	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r1	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r1	tests/.branch.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(true,())));),OBJ(string,"PASS: If True"),OBJ(string,"FAIL: If True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(false,())));),OBJ(string,"FAIL: If False"),OBJ(string,"PASS: If False")));const cognate_object r1 = pop();CALL(print,(r1));)$/;"	v
r1	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r1	tests/.stack.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(number,2));CALL(drop,(OBJ(number,3)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,2),r0))));),OBJ(string,"PASS: Drop"),OBJ(string,"FAIL: Drop")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(CALL(swap,(OBJ(number,6),OBJ(number,5)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,5),r0))));),OBJ(string,"PASS: Swap"),OBJ(string,"FAIL: Swap")));const cognate_object r1 = pop();CALL(print,(r1));const cognate_object r2 = pop();CALL(drop,(r2));CALL(if,(BLOCK(CALL(twin,(OBJ(number,4)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,4),r1))));),OBJ(string,"PASS: Twin"),OBJ(string,"FAIL: Twin")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(CALL(triplet,(OBJ(number,7)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();CALL(drop,(r1));const cognate_object r2 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,7),r2))));),OBJ(string,"PASS: Triplet"),OBJ(string,"FAIL: Triplet")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(number,1));push(OBJ(number,2));push(OBJ(number,3));CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK(push(OBJ(number,1)); push(OBJ(number,2)); push(OBJ(number,3));)))),r0))));),OBJ(string,"PASS: Stack as list"),OBJ(string,"FAIL: Stack as list")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(CALL(clear,());CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK()))),r0))));),OBJ(string,"PASS: Clearing the stack"),OBJ(string,"FAIL: Clearing the stack")));const cognate_object r6 = pop();CALL(print,(r6));)$/;"	v
r1	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r10	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r11	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r12	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r13	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r2	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r2	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r2	tests/.stack.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(number,2));CALL(drop,(OBJ(number,3)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,2),r0))));),OBJ(string,"PASS: Drop"),OBJ(string,"FAIL: Drop")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(CALL(swap,(OBJ(number,6),OBJ(number,5)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,5),r0))));),OBJ(string,"PASS: Swap"),OBJ(string,"FAIL: Swap")));const cognate_object r1 = pop();CALL(print,(r1));const cognate_object r2 = pop();CALL(drop,(r2));CALL(if,(BLOCK(CALL(twin,(OBJ(number,4)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,4),r1))));),OBJ(string,"PASS: Twin"),OBJ(string,"FAIL: Twin")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(CALL(triplet,(OBJ(number,7)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();CALL(drop,(r1));const cognate_object r2 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,7),r2))));),OBJ(string,"PASS: Triplet"),OBJ(string,"FAIL: Triplet")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(number,1));push(OBJ(number,2));push(OBJ(number,3));CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK(push(OBJ(number,1)); push(OBJ(number,2)); push(OBJ(number,3));)))),r0))));),OBJ(string,"PASS: Stack as list"),OBJ(string,"FAIL: Stack as list")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(CALL(clear,());CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK()))),r0))));),OBJ(string,"PASS: Clearing the stack"),OBJ(string,"FAIL: Clearing the stack")));const cognate_object r6 = pop();CALL(print,(r6));)$/;"	v
r2	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r3	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r3	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r3	tests/.stack.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(number,2));CALL(drop,(OBJ(number,3)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,2),r0))));),OBJ(string,"PASS: Drop"),OBJ(string,"FAIL: Drop")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(CALL(swap,(OBJ(number,6),OBJ(number,5)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,5),r0))));),OBJ(string,"PASS: Swap"),OBJ(string,"FAIL: Swap")));const cognate_object r1 = pop();CALL(print,(r1));const cognate_object r2 = pop();CALL(drop,(r2));CALL(if,(BLOCK(CALL(twin,(OBJ(number,4)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,4),r1))));),OBJ(string,"PASS: Twin"),OBJ(string,"FAIL: Twin")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(CALL(triplet,(OBJ(number,7)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();CALL(drop,(r1));const cognate_object r2 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,7),r2))));),OBJ(string,"PASS: Triplet"),OBJ(string,"FAIL: Triplet")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(number,1));push(OBJ(number,2));push(OBJ(number,3));CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK(push(OBJ(number,1)); push(OBJ(number,2)); push(OBJ(number,3));)))),r0))));),OBJ(string,"PASS: Stack as list"),OBJ(string,"FAIL: Stack as list")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(CALL(clear,());CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK()))),r0))));),OBJ(string,"PASS: Clearing the stack"),OBJ(string,"FAIL: Clearing the stack")));const cognate_object r6 = pop();CALL(print,(r6));)$/;"	v
r3	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r4	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r4	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r4	tests/.stack.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(number,2));CALL(drop,(OBJ(number,3)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,2),r0))));),OBJ(string,"PASS: Drop"),OBJ(string,"FAIL: Drop")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(CALL(swap,(OBJ(number,6),OBJ(number,5)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,5),r0))));),OBJ(string,"PASS: Swap"),OBJ(string,"FAIL: Swap")));const cognate_object r1 = pop();CALL(print,(r1));const cognate_object r2 = pop();CALL(drop,(r2));CALL(if,(BLOCK(CALL(twin,(OBJ(number,4)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,4),r1))));),OBJ(string,"PASS: Twin"),OBJ(string,"FAIL: Twin")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(CALL(triplet,(OBJ(number,7)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();CALL(drop,(r1));const cognate_object r2 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,7),r2))));),OBJ(string,"PASS: Triplet"),OBJ(string,"FAIL: Triplet")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(number,1));push(OBJ(number,2));push(OBJ(number,3));CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK(push(OBJ(number,1)); push(OBJ(number,2)); push(OBJ(number,3));)))),r0))));),OBJ(string,"PASS: Stack as list"),OBJ(string,"FAIL: Stack as list")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(CALL(clear,());CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK()))),r0))));),OBJ(string,"PASS: Clearing the stack"),OBJ(string,"FAIL: Clearing the stack")));const cognate_object r6 = pop();CALL(print,(r6));)$/;"	v
r4	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r5	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r5	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r5	tests/.stack.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(number,2));CALL(drop,(OBJ(number,3)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,2),r0))));),OBJ(string,"PASS: Drop"),OBJ(string,"FAIL: Drop")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(CALL(swap,(OBJ(number,6),OBJ(number,5)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,5),r0))));),OBJ(string,"PASS: Swap"),OBJ(string,"FAIL: Swap")));const cognate_object r1 = pop();CALL(print,(r1));const cognate_object r2 = pop();CALL(drop,(r2));CALL(if,(BLOCK(CALL(twin,(OBJ(number,4)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,4),r1))));),OBJ(string,"PASS: Twin"),OBJ(string,"FAIL: Twin")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(CALL(triplet,(OBJ(number,7)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();CALL(drop,(r1));const cognate_object r2 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,7),r2))));),OBJ(string,"PASS: Triplet"),OBJ(string,"FAIL: Triplet")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(number,1));push(OBJ(number,2));push(OBJ(number,3));CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK(push(OBJ(number,1)); push(OBJ(number,2)); push(OBJ(number,3));)))),r0))));),OBJ(string,"PASS: Stack as list"),OBJ(string,"FAIL: Stack as list")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(CALL(clear,());CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK()))),r0))));),OBJ(string,"PASS: Clearing the stack"),OBJ(string,"FAIL: Clearing the stack")));const cognate_object r6 = pop();CALL(print,(r6));)$/;"	v
r5	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r6	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r6	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r6	tests/.stack.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(number,2));CALL(drop,(OBJ(number,3)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,2),r0))));),OBJ(string,"PASS: Drop"),OBJ(string,"FAIL: Drop")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(CALL(swap,(OBJ(number,6),OBJ(number,5)));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,5),r0))));),OBJ(string,"PASS: Swap"),OBJ(string,"FAIL: Swap")));const cognate_object r1 = pop();CALL(print,(r1));const cognate_object r2 = pop();CALL(drop,(r2));CALL(if,(BLOCK(CALL(twin,(OBJ(number,4)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,4),r1))));),OBJ(string,"PASS: Twin"),OBJ(string,"FAIL: Twin")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(CALL(triplet,(OBJ(number,7)));const cognate_object r0 = pop();CALL(drop,(r0));const cognate_object r1 = pop();CALL(drop,(r1));const cognate_object r2 = pop();push(OBJ(boolean,CALL(equal,(OBJ(number,7),r2))));),OBJ(string,"PASS: Triplet"),OBJ(string,"FAIL: Triplet")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(number,1));push(OBJ(number,2));push(OBJ(number,3));CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK(push(OBJ(number,1)); push(OBJ(number,2)); push(OBJ(number,3));)))),r0))));),OBJ(string,"PASS: Stack as list"),OBJ(string,"FAIL: Stack as list")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(CALL(clear,());CALL(stack,());const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(list,CALL(list,(BLOCK()))),r0))));),OBJ(string,"PASS: Clearing the stack"),OBJ(string,"FAIL: Clearing the stack")));const cognate_object r6 = pop();CALL(print,(r6));)$/;"	v
r6	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r7	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r7	tests/.maths.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,11),OBJ(number,CALL(sum,(5,6)))))));),OBJ(string,"PASS: Addition"),OBJ(string,"FAIL: Addition")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9),OBJ(number,CALL(subtract,(10,19)))))));),OBJ(string,"PASS: Subtraction"),OBJ(string,"FAIL: Subtraction")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,72),OBJ(number,CALL(multiply,(9,8)))))));),OBJ(string,"PASS: Multiplication"),OBJ(string,"FAIL: Multiplication")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,6),OBJ(number,CALL(divide,(7,42)))))));),OBJ(string,"PASS: Division"),OBJ(string,"FAIL: Division")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,1),OBJ(number,CALL(modulo,(3,10)))))));),OBJ(string,"PASS: Modulus"),OBJ(string,"FAIL: Modulus")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,4),OBJ(number,CALL(floor,(4.7)))))));),OBJ(string,"PASS: Floor"),OBJ(string,"FAIL: Floor")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(ceiling,(4.3)))))));),OBJ(string,"PASS: Ceiling"),OBJ(string,"FAIL: Ceiling")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,5),OBJ(number,CALL(round,(4.7)))))));),OBJ(string,"PASS: Round"),OBJ(string,"FAIL: Round")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r7	tests/.strings.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(string," ☺"));push(OBJ(string," world"));push(OBJ(string,"Hello"));CALL(join,(3));const cognate_object r0 = pop();push(OBJ(boolean,CALL(equal,(OBJ(string,"Hello world ☺"),r0))));),OBJ(string,"PASS: Converting list of strings to combined string"),OBJ(string,"FAIL: Converting list of characters to combined string")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,9786),OBJ(number,CALL(ordinal,("☺")))))));),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal"),OBJ(string,"PASS: Converting string to UTF8 value with Ordinal")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"☺"),OBJ(string,CALL(character,(9786)))))));),OBJ(string,"PASS: Converting UTF8 value to string"),OBJ(string,"FAIL: Converting UTF8 value to string")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(number,123.4),OBJ(number,CALL(number,("123.4")))))));),OBJ(string,"PASS: Casting strings to numbers"),OBJ(string,"PASS: Casting strings to numbers")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"H"),OBJ(string,CALL(head,("Hello")))))));),OBJ(string,"PASS: Getting Head of string"),OBJ(string,"FAIL: Getting Head of string")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"e"),OBJ(string,CALL(head,("e")))))));),OBJ(string,"PASS: Getting Head of single-character string"),OBJ(string,"FAIL: Getting Head of single-character string")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,"ello"),OBJ(string,CALL(tail,("Hello")))))));),OBJ(string,"PASS: Getting Tail of string"),OBJ(string,"FAIL: Getting Tail of string")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(string,""),OBJ(string,CALL(tail,("e")))))));),OBJ(string,"PASS: Getting Tail of single-character string"),OBJ(string,"FAIL: Getting Tail of single-character string")));const cognate_object r7 = pop();CALL(print,(r7));)$/;"	v
r8	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
r9	tests/.booleans.c	/^PROGRAM(CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True AND True"),OBJ(string,"FAIL: True AND True")));const cognate_object r0 = pop();CALL(print,(r0));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True AND False"),OBJ(string,"FAIL: True AND False")));const cognate_object r1 = pop();CALL(print,(r1));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False AND True"),OBJ(string,"FAIL: False AND True")));const cognate_object r2 = pop();CALL(print,(r2));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(both,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False AND False"),OBJ(string,"FAIL: False AND False")));const cognate_object r3 = pop();CALL(print,(r3));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True OR True"),OBJ(string,"FAIL: True OR True")));const cognate_object r4 = pop();CALL(print,(r4));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True OR False"),OBJ(string,"FAIL: True OR False")));const cognate_object r5 = pop();CALL(print,(r5));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False OR True"),OBJ(string,"FAIL: False OR True")));const cognate_object r6 = pop();CALL(print,(r6));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(either,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False OR False"),OBJ(string,"FAIL: False OR False")));const cognate_object r7 = pop();CALL(print,(r7));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(true,()))))))));),OBJ(string,"PASS: True XOR True"),OBJ(string,"FAIL: True XOR True")));const cognate_object r8 = pop();CALL(print,(r8));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(true,()),CALL(false,()))))))));),OBJ(string,"PASS: True XOR False"),OBJ(string,"FAIL: True XOR False")));const cognate_object r9 = pop();CALL(print,(r9));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(true,()))))))));),OBJ(string,"PASS: False XOR True"),OBJ(string,"FAIL: False XOR True")));const cognate_object r10 = pop();CALL(print,(r10));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(one_of,(CALL(false,()),CALL(false,()))))))));),OBJ(string,"PASS: False XOR False"),OBJ(string,"FAIL: False XOR False")));const cognate_object r11 = pop();CALL(print,(r11));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(false,())),OBJ(boolean,CALL(not,(CALL(true,()))))))));),OBJ(string,"PASS: NOT True"),OBJ(string,"PASS: NOT True")));const cognate_object r12 = pop();CALL(print,(r12));CALL(if,(BLOCK(push(OBJ(boolean,CALL(equal,(OBJ(boolean,CALL(true,())),OBJ(boolean,CALL(not,(CALL(false,()))))))));),OBJ(string,"PASS: NOT False"),OBJ(string,"PASS: NOT False")));const cognate_object r13 = pop();CALL(print,(r13));)$/;"	v
set_current_word_name	runtime.c	/^void set_current_word_name(const char* const name) { current_word_name=name; } \/\/ Need this to avoid unsequenced evaluation error.$/;"	f
size	cognate.h	/^  ptrdiff_t       size; \/\/ Allocated size of the stack.$/;"	m	struct:cognate_stack
stack	runtime.c	/^cognate_stack stack;$/;"	v
start	cognate.h	/^  cognate_object* restrict start; \/\/ Pointer to start.$/;"	m	struct:cognate_stack
string	cognate.h	/^    cognate_string  string;    \/\/ 64bit string pointer$/;"	m	union:cognate_object::__anon1
string	cognate.h	/^  string = (1 << 1),$/;"	e	enum:cognate_type
table	cognate.h	/^    cognate_table   table;     \/\/ TODO$/;"	m	union:cognate_object::__anon1
table	cognate.h	/^  table = (1 << 4),$/;"	e	enum:cognate_type
throw_error	runtime.c	/^_Noreturn __attribute__((format(printf, 1, 2))) void throw_error(const char* const fmt, ...)$/;"	f
top	cognate.h	/^  cognate_object* restrict top; \/\/ Pointer to top.$/;"	m	struct:cognate_stack
type	cognate.h	/^  cognate_type type;$/;"	m	struct:cognate_object
uncopied_blocks	cognate.h	/^  size_t          uncopied_blocks; \/\/ Number of uncopied cognate_blocks on the stack.$/;"	m	struct:cognate_stack
unlikely	cognate.h	134;"	d
